package com.tl.thread.vola;

/**
 * volatile 关键字底层原理
 */
public class VolatileTest {

    /**
     * cpu 与主存的速度不一致所以引进高速缓存(L1,L2,L3 三级缓存)
     *      多核cpu下操作共享数据带来缓存一致性的问题，解决缓存一致性的问题有 1.总线加锁 2. 窥探技术+MESI协议
     *
     *
     *      volatile 作用
     *          1. 数据可见性，一个线程对被volatile修饰变量作出修改的时候，另一个线程会当即知道
     *          2. 禁止指令重排序
     *      单线程环境下，编译器和处理器会对我们代码做一些优化，可能会发生指令的重排序，但是单线程环境下遵循as-if-Serial 内存语义，
     *      保证有数据依赖性的数据操作是不会被重排序的， 即最后运行的结果是一致的
     *
     *      怎么保证可见性？
     *          happen-before 规则，
     *              happen-before规则怎么实现的？
     *                  内存屏障--》 内存屏障简单说是干啥的？ 确定有数据依赖关系的操作的指令的执行先后顺序
     */
}

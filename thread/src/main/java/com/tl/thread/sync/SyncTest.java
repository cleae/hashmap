package com.tl.thread.sync;


import java.util.ArrayList;
import java.util.List;

/**
 * synchronized 底层原理
 *      参考资料
 *          https://tech.meituan.com/2018/11/15/java-lock.html
 */
public class SyncTest {

    /**
     * java对象在内存中的分布
     *      1、对象头
     *          Mark Word :存储对象的hashcode 或者锁信息
     *              动态数据结构
     *
     *          类型指针:指向对象的元数据信息，例如可以由此知道该对象属于哪个类
     *          ArrayLength: 如果对象是数组类型，还要记录长度
     *     2、 实例数据
     *          存储对象的实例数据
     *     3、 对齐数据
     *          无实际意义，jvm自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍，不足时需要对齐填充来补全
     *      每一个java对象都有一个Monitor 对象与之关联，称为monitor 锁，
     *          jvm层面， jvm基于进入和退出monitor对象来实现代码块同步和方法同步的  monitorEnter monitorExit 指令
     *       monitor对象的数据结构(主要核心的几个如下)：
     *          _owner  :指向持有monitor对象锁的线程
     *          _EntryList : 阻塞队列的线程
     *          _WaitSet : 等待队列中的线程
     *          _count : 记录冲入次数
     *       java 虚拟机栈是线程私有的数据结构，每个方法在执行的时候都会创建一个栈帧， 用于存储局部变量表、操作数栈、动态链接、方法出口信息
     *          每一个线程都有一个可用monitor record列表，记录持有了那些对象的monitor对象锁🔒
     *
     *       synchronize 优化
     *          jdk1.6之前 synchronize 关键字效率并不高，从jdk1.6 开始对其实现机制进行了较大的调整
     *              引入了 自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁 这些策略
     *                  CAS自旋锁：
     *                      为什么引入自旋锁？
     *                          用户态与核心态之间的转换
     *                              内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
     *                              用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取
     *                              用户态--》核心态
     *                                  系统调用
     *                                  中断
     *                                  异常
     *                              java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态与核心态之间切换，这种切换会消耗大量的系统资源
     *
     *                              由上可知阻塞或者唤醒线程开销较大，而且一般情况下monitor锁的被持有时间较短，所以不值得频繁的阻塞或者唤醒线程
     *                              由此引进自旋锁
     *                                  当线程尝试获取某个对象的monitor锁的时候，如果该锁已经被其他线程所占有，就一直循环检测锁是否被释放，
     *                                  而不是直接进入阻塞状态
     *                                  那么问题来了，自旋多少次合适？也不可能说一直无限次的循环检测，这样效率也低(参cas操作的缺点)
     *                                      JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。
     *                                      这样还是不够智能，于是有了自适应的自旋锁
     *
     *                  自适应的CAS自旋：
     *                      自旋的次数是不确定的，如果上一次自旋操作成功了，那么虚拟机会认为既然上一次成功了这一次很可能会再次成功，自然而然地会允许自旋
     *                      的次数多一点，相反的对于某一个monitor锁，自旋操作总是不成功，则减少自旋次数甚至略掉自旋操作
     *
     *                  锁消除：
     *                      如果某个同步代码块不涉及多线程情况下的对临界变量的写操作，即没有线程不安全的操作，jvm会将加锁操作消除 见LockRemove类
     *                  锁粗化：
     *                      如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 见LockRough类
     *       锁升级
     *          无锁
     *              无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。
     *          偏向锁
     *              偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
     *              在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。
     *
     *              当一个线程访问同步代码块并获取锁的时候，会在mark word 李存储偏向的线程ID ,在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，
     *              而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，
     *              因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。
     *
     *              执行流程如下：
     *                  1、检测对象头Mark Word中是否为可偏向的状态，1|01
     *                  2、检测偏向线程ID是否是当前线程，是执行步骤5，否执行步骤3
     *                  3、通过CAS操作竞争锁，竞争成功，把对象头的Mark Word 的偏向线程ID置为当前线程，竞争失败 执行步骤4
     *                  4、偏向锁的撤销，偏向锁使用了一种等待竞争出现才释放锁的机制，线程不会主动释放偏向锁，偏向锁的撤销要等到全局安全点，
     *                  这个时候没有正在执行的字节码，首先先暂停拥有偏向锁的线程，然后检测持有锁的线程是否还活着？
     *                      否，将对象头置成无所状态
     *                      是，将对象头的Mark Word 中的指针指向被挂起线程的栈中的锁记录，升级为轻量级锁，恢复被挂起的线程，进入到轻量级锁的竞争状态
     *
     *                      注意：当前线程的挂起和恢复过程中没有发生锁的转移  只是 “将对象头中的线程ID变更为指向锁记录地址的指针”
     *                  5、执行同步代码块的内容
     *
     *          轻量级锁
     *              当锁是偏向锁的时候，被另外的线程竞争，偏向锁就可能会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
     *              在线程进入同步代码块的时候，如果此同步对象没有被锁定，即它的锁标志位是0|01，
     *              则虚拟机首先在当前线程的栈中创建我们称之为“锁记录（Lock Record）”的空间，用于存储锁对象的Mark Word的拷贝
     *              Lock Record的内部结构(部分)：
     *                  Owner：指向对象的Mark Word
     *                  nest：重入次数
     *             拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。
     *
     *          如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
     *
     *          如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，
     *          那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。
     *          但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
     *
     *          重量级锁
     *              升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。
     *
     * @param args
     */
    public static void main(String[] args) {
//        List<Number> ls = new ArrayList<Integer>();
//        Number number =new Integer(2);
        System.out.println();
    }
}
